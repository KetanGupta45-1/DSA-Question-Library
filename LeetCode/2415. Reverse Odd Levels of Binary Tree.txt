Explanation
Perform a level-order traversal (BFS) using a queue to process nodes level by level.
For each level, collect all nodes in a temporary vector nodes.
If the level is odd, reverse node values by swapping from both ends (i, j).
Continue BFS until all levels are processed, and finally return the modified root.

Complexity
Time: O(n) → every node is visited once, and values may be swapped per level.
Space: O(n) → for the queue and temporary nodes vector at each level.

Code
class Solution {
public:
    TreeNode* reverseOddLevels(TreeNode* root) {
        queue<TreeNode*> q;
        int level = 0;
        q.push(root);

        while (!q.empty()) 
        {
            int n = q.size();
            vector<TreeNode*> nodes;

            for (int i = 0; i < n; ++i) 
            {
                TreeNode* curr = q.front(); 
                q.pop();
                nodes.push_back(curr);

                if (curr->left) 
                    q.push(curr->left);
                if (curr->right) 
                    q.push(curr->right);
            }

            if (level % 2 == 1) 
            {
                int i = 0, j = nodes.size() - 1;
                while (i < j) 
                {
                    swap(nodes[i]->val, nodes[j]->val);
                    i++;
                    j--;
                }
            }
            level++;
        }
        return root;
    }
};
Approach 1: Brute Force (Check All Elements)

Explanation
Traverse through every element of the matrix using two nested loops.
If any element matches the target, return true.
Otherwise, after scanning all elements, return false.

Time Complexity
O(m × n) → where m = number of rows, n = number of columns.

Space Complexity
O(1) → only loop variables are used.

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();

        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(matrix[i][j] == target)
                    return true;
            }
        }
        return false;
    }
};


-------------------------------------------------------------------------------------------------------------------------------------------
Approach 2: Two-Step Binary Search

Explanation
Use binary search on the first and last elements of rows to find the possible row where the target can exist.
Then, perform binary search within that row to find the target.
This reduces the unnecessary search across rows.

Time Complexity
Binary search to find row → O(log m)
Binary search within row → O(log n)
Total → O(log m + log n)

Space Complexity
O(1) → no extra data structures used.

class Solution {
public:
    int findRow(vector<vector<int>>& matrix, int target)
    {
        int m = matrix.size();
        int n = matrix[0].size();
        int s = 0, e = m - 1;

        while(s <= e)
        {
            int mid = s + (e - s) / 2;
            if(matrix[mid][0] <= target && matrix[mid][n - 1] >= target)
                return mid;
            else if(matrix[mid][0] > target)
                e = mid - 1;
            else
                s = mid + 1;
        }
        return -1;
    }

    bool binarySearchRow(vector<vector<int>>& matrix, int row, int target)
    {
        int s = 0, e = matrix[0].size() - 1;
        while(s <= e)
        {
            int mid = s + (e - s) / 2;
            if(matrix[row][mid] == target)
                return true;
            else if(matrix[row][mid] > target)
                e = mid - 1;
            else
                s = mid + 1;
        }
        return false;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = findRow(matrix, target);
        if(row == -1) return false;
        return binarySearchRow(matrix, row, target);
    }
};


-------------------------------------------------------------------------------------------------------------------------------------------
Approach 3: Flattened Matrix Binary Search (Most Optimized)

Explanation
Treat the 2D matrix as a 1D sorted array of size m × n.
Perform a single binary search over this virtual array.
For any index mid:
Row = mid / n
Column = mid % n
Compare matrix[row][col] with the target and adjust search space.

Time Complexity
O(log(m × n))
Equivalent to O(log m + log n), but in one clean binary search.
Space Complexity
O(1)

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();

        int s = 0, e = m * n - 1;
        while(s <= e)
        {
            int mid = s + (e - s) / 2;
            int row = mid / n;
            int col = mid % n;

            if(matrix[row][col] == target)
                return true;
            else if(matrix[row][col] > target)
                e = mid - 1;
            else
                s = mid + 1;
        }
        return false;
    }
};

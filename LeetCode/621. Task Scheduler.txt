ðŸŸ¢ Brute Force (Simulation)
-------------------------------------------------------------------------------------------------------------------------------------

Explanation (4 Points)
Use a priority queue to always pick the task with the highest remaining count.
Simulate each cycle of length n+1, placing tasks or idle slots.
Push remaining tasks back into the queue for the next round.
Continue until all tasks are finished, counting time units.

Complexity
Time: O(T Â· log 26) â‰ˆ O(T log T), T = total tasks.
Space: O(26) = O(1).

Code
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> freq(26, 0);
        for(char c : tasks) freq[c - 'A']++;
        
        priority_queue<int> pq;
        for(int f : freq) if(f > 0) pq.push(f);

        int time = 0;
        while(!pq.empty()) {
            vector<int> temp;
            int cycle = n + 1;

            while(cycle-- && !pq.empty()) {
                int curr = pq.top(); pq.pop();
                if(--curr > 0) temp.push_back(curr);
                time++;
            }
            for(int t : temp) pq.push(t);

            if(!pq.empty()) time += cycle + 1;
        }
        return time;
    }
};

-------------------------------------------------------------------------------------------------------------------------------------
ðŸŸ  Greedy (Bucket Filling)
-------------------------------------------------------------------------------------------------------------------------------------

Explanation (4 Points)
Sort task frequencies in descending order.
Place the most frequent tasks into buckets separated by n.
Try to fill gaps with other tasks to minimize idle time.
If enough tasks exist, idle slots are filled; otherwise, idle time remains.

Complexity
Time: O(26 log 26) = O(1).
Space: O(26) = O(1).

Code
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> freq(26, 0);
        for(char c : tasks) freq[c - 'A']++;
        sort(freq.begin(), freq.end(), greater<int>());

        int max_count = freq[0] - 1;
        int idle_slots = max_count * n;

        for(int i = 1; i < 26 && idle_slots > 0; i++) {
            idle_slots -= min(max_count, freq[i]);
        }
        idle_slots = max(0, idle_slots);

        return tasks.size() + idle_slots;
    }
};

-------------------------------------------------------------------------------------------------------------------------------------
ðŸ”µ Formula Method (Optimized Greedy)
-------------------------------------------------------------------------------------------------------------------------------------

Explanation (4 Points)
Let max_count = highest task frequency.Arrange these tasks first: (max_count - 1) * (n + 1) forms base length.
Count how many tasks share this frequency â†’ num_max.
Final answer = max(tasks.size(), (max_count - 1) * (n + 1) + num_max).

Complexity
Time: O(26) = O(1).
Space: O(26) = O(1).

Code (your version)
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> freq(26, 0);
        for(auto c : tasks) freq[c - 'A']++;

        int max_count = *max_element(freq.begin(), freq.end());
        int ans = (max_count - 1) * (n + 1);

        for(int f : freq)
            if(f == max_count) ans++;

        return max((int)tasks.size(), ans);
    }
};
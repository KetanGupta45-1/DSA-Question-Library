Brute Force Approach
-------------------------------------------------------------------------------------------------------------------------------------

Explanation
Start from the root as the first element of the preorder array.
For each subsequent element, insert it into the BST using standard BST insertion logic (O(h) per insertion).
Repeat for all elements until the BST is built.

Time Complexity
Worst case: O(nÂ²) (if the tree becomes skewed).
Best case (balanced tree): O(n log n).
Space Complexity
O(h) recursion/stack space for insertion (worst case O(n)).

Code
class Solution {
public:
    TreeNode* insert(TreeNode* root, int val) {
        if(!root) return new TreeNode(val);
        if(val < root->val) root->left = insert(root->left, val);
        else root->right = insert(root->right, val);
        return root;
    }

    TreeNode* bstFromPreorder(vector<int>& preorder) {
        TreeNode* root = nullptr;
        for(int x : preorder)
            root = insert(root, x);
        return root;
    }
};


-------------------------------------------------------------------------------------------------------------------------------------
ðŸŸ  Optimized Approach
-------------------------------------------------------------------------------------------------------------------------------------

Explanation
Use recursion with bounds (mini, maxi) and an index pointer i.
At each step, if preorder[i] lies outside bounds, return null.
Otherwise, create a node and recursively build its left and right subtrees with updated bounds.
This avoids repeated searching/insertion and ensures preorder is consumed in order.

Time Complexity
O(n) â†’ each element processed exactly once.
Space Complexity
O(h) recursion stack, worst O(n).

Code
class Solution {
public:
    TreeNode* helper(vector<int>& preorder, int& i, int mini, int maxi) {
        if(i == preorder.size() || preorder[i] < mini || preorder[i] > maxi)
            return nullptr;

        TreeNode* root = new TreeNode(preorder[i++]);
        root->left = helper(preorder, i, mini, root->val);
        root->right = helper(preorder, i, root->val, maxi);
        return root;
    }

    TreeNode* bstFromPreorder(vector<int>& preorder) {
        int i = 0;
        return helper(preorder, i, INT_MIN, INT_MAX);
    }
};
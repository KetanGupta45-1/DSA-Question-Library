Brute Force (Your Code)
-------------------------------------------------------------------------------------------------

Idea
Split text into words manually.
For each word, check every character against broken_letters.
Count how many words contain broken letters â†’ subtract from total words.

Complexity
TC: O(L * W) where L = text length, W = avg word length. Essentially O(total characters).
SC: O(L) for storing all words.

Code (Brute Force)
class Solution {
public:
    int canBeTypedWords(string text, string broken_letters) {
        vector<string> words;
        vector<int> map(26);

        for(auto &c : broken_letters)
            map[c - 'a']++;

        int n = text.size();
        int i = 0;
        while(i < n) {
            int j = i;
            string s = "";
            while(j < n && text[j] != ' ') {
                s += text[j];
                j++;
            }
            words.push_back(s);
            i = j + 1;
        }

        n = words.size();
        int count = 0;
        for(auto &word : words) {
            for(auto &c : word) {
                if(map[c - 'a'] > 0) {
                    count++;
                    break;
                }
            }
        }
        return n - count;
    }
};


-------------------------------------------------------------------------------------------------
Optimized (No Extra Storage)
-------------------------------------------------------------------------------------------------

Idea
Instead of storing words, process directly while scanning text.
Use a boolean valid to track if current word is typable.
When encountering space/end, add to answer if valid.

Complexity
TC: O(L) (single pass over text).
SC: O(1) (only array for broken letters).

Code (Optimized)
class Solution {
public:
    int canBeTypedWords(string text, string broken_letters) {
        vector<int> broken(26);
        for(char c : broken_letters) 
            broken[c - 'a'] = 1;

        int ans = 0;
        bool valid = true;

        for(int i = 0; i <= text.size(); i++) {
            if(i < text.size() && text[i] != ' ') {
                if(broken[text[i] - 'a']) valid = false;
            } else {
                if(valid) ans++;
                valid = true;
            }
        }
        return ans;
    }
};



-------------------------------------------------------------------------------------------------
Stringstream Approach
-------------------------------------------------------------------------------------------------

Idea
Use stringstream to split text into words.
For each word, check if any broken letter exists.
If not, count it as typable.

Complexity
TC: O(L) (iterate all characters once).
SC: O(W) for temporary words in the stream.

Code (Stringstream)
class Solution {
public:
    int canBeTypedWords(string text, string broken_letters) {
        vector<int> broken(26);
        for(char c : broken_letters) 
            broken[c - 'a'] = 1;

        stringstream ss(text);
        string word;
        int ans = 0;

        while(ss >> word) {
            bool valid = true;
            for(char c : word) {
                if(broken[c - 'a']) {
                    valid = false;
                    break;
                }
            }
            if(valid) ans++;
        }
        return ans;
    }
};

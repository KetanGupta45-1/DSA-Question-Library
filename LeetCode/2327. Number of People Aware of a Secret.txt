1. Brute Force Simulation
-------------------------------------------------------------------------------------------------
Explanation
Track each person individually: when they learn, when they can share, when they forget.
For each day 1 → n, check every active person.
If they are in [learn+delay, learn+forget-1], they share with new people.
Count how many still remember at day n.

Complexity
TC: O(n^2) (every day × people sharing).
SC: O(n^2) (store all people).

Code
class Solution {
public:
    int mod = 1e9+7;
    int peopleAwareOfSecret(int n, int delay, int forget) {
        vector<vector<int>> people; 
        people.push_back({1, 1}); // {day_learned, count}
        
        for(int day=2; day<=n; day++) {
            long long new_people = 0;
            for(auto &p : people) {
                int learned = p[0], cnt = p[1];
                if(day >= learned+delay && day < learned+forget)
                    new_people = (new_people + cnt) % mod;
            }
            if(new_people > 0)
                people.push_back({day, (int)new_people});
        }

        long long ans = 0;
        for(auto &p : people) {
            if(p[0] + forget > n)
                ans = (ans + p[1]) % mod;
        }
        return ans;
    }
};


-------------------------------------------------------------------------------------------------
2. Recursion + Memoization
-------------------------------------------------------------------------------------------------

Explanation
Define f(day) = number of people who learn secret on this day.
Base: f(1) = 1.

Transition:
f(day) = sum( f(prev) )  where prev in [day-forget+1, day-delay]
Memoize to avoid recomputation.
Answer = sum of f(d) for last forget-1 days.

Complexity
TC: O(n * forget) (each state checks up to forget prev days).
SC: O(n) (memo + recursion stack).

Code
class Solution {
public:
    int mod = 1e9+7;
    vector<int> memo;
    int delay, forget;

    long long f(int day) {
        if(day == 1) return 1;
        if(memo[day] != -1) return memo[day];

        long long res = 0;
        for(int prev=day-forget+1; prev<=day-delay; prev++) {
            if(prev > 0)
                res = (res + f(prev)) % mod;
        }
        return memo[day] = res;
    }

    int peopleAwareOfSecret(int n, int d, int fgt) {
        delay = d; forget = fgt;
        memo.assign(n+1, -1);
        
        long long ans = 0;
        for(int day=n-forget+1; day<=n; day++) {
            if(day > 0) ans = (ans + f(day)) % mod;
        }
        return ans;
    }
};


-------------------------------------------------------------------------------------------------
3. DP (Bottom-Up)
-------------------------------------------------------------------------------------------------

Explanation
Create dp[day] = number of people who learn secret on day.
Initialize: dp[1] = 1.
For each day, distribute contributions to [day+delay … day+forget-1].
Answer = sum of dp[day] for days in [n-forget+1 … n].

Complexity
TC: O(n * forget) (can optimize with prefix sums to O(n)).
SC: O(n).

Code
class Solution {
public:
    int mod = 1e9+7;
    int peopleAwareOfSecret(int n, int delay, int forget) {
        vector<long long> dp(n+1, 0);
        dp[1] = 1;

        for(int day=2; day<=n; day++) {
            long long count = 0;
            for(int prev=day-forget+1; prev<=day-delay; prev++) {
                if(prev > 0) count = (count + dp[prev]) % mod;
            }
            dp[day] = count;
        }

        long long ans = 0;
        for(int day=n-forget+1; day<=n; day++) {
            if(day > 0) ans = (ans + dp[day]) % mod;
        }
        return ans % mod;
    }
};
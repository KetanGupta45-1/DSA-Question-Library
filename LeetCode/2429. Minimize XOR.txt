Explanation
Count the number of set bits in num2 (requiredSetBitCount).
Start with x = num1 and count its set bits (currSetBitCount).
Adjust x to have the same number of set bits as num2:
If currSetBitCount < requiredSetBitCount, set additional 0 bits from least significant bit upwards.
If currSetBitCount > requiredSetBitCount, unset 1 bits from least significant bit upwards.
Return the modified x which minimizes num1 XOR x while matching the set bit count of num2.

Complexity
Time: O(32) → iterate over at most 32 bits of the integer.
Space: O(1) → no extra space beyond counters.

Code
class Solution {
public:
    bool isSet(int &x, int bit) 
    {
        return x & (1 << bit);
    }

    bool setBit(int &x, int bit)
    {
        return x |= (1 << bit);
    }

    bool unsetBit(int &x, int bit) 
    {
        return x &= ~(1 << bit);
    }

    int minimizeXor(int num1, int num2) 
    {
        int x = num1;

        int requiredSetBitCount = __builtin_popcount(num2);
        int currSetBitCount = __builtin_popcount(x);

        int bit = 0;
        if(currSetBitCount < requiredSetBitCount) 
        {
            while(currSetBitCount < requiredSetBitCount) 
            {
                if(!isSet(x, bit)) 
                {
                    setBit(x, bit);
                    currSetBitCount++;
                }
                bit++;
            }
        } 
        else if(currSetBitCount > requiredSetBitCount) 
        {
            while(currSetBitCount > requiredSetBitCount) 
            {
                if(isSet(x, bit)) 
                {
                    unsetBit(x, bit);
                    currSetBitCount--;
                }
                bit++;
            }
        }

        return x;
    }
};
Explanation
Use DFS recursion to traverse the tree.
For each node, recursively compute the depth of the left and right subtrees.
Take the maximum of the left and right depths and add 1 for the current node.
Base case: if the node is nullptr, return 0.

Complexity
Time: O(n) → every node is visited once.
Space: O(h) → recursion stack space (h = height of the tree).

Code
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;

        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
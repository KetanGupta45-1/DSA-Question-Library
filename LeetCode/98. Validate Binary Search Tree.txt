Inorder Based
-------------------------------------------------------------------------------------------------
Explanation (4 bullets)
Each node must lie within a valid range (min, max).
Left child: max bound becomes parent’s value.
Right child: min bound becomes parent’s value.
If any node violates the range, return false; otherwise recurse down.

Complexity
Time: O(n) → each node visited once.
Space: O(h) recursion stack (h = tree height, O(log n) for balanced, O(n) for skewed).

Code
class Solution {
public:
    bool check(TreeNode* root, long long mini, long long maxi)
    {
        if(!root) return true;
        if(root->val <= mini || root->val >= maxi) return false;
        return check(root->left, mini, root->val) && check(root->right, root->val, maxi);
    }

    bool isValidBST(TreeNode* root) 
    {
        return check(root, LLONG_MIN, LLONG_MAX);
    }
};


-------------------------------------------------------------------------------------------------
Stack Based Approach
-------------------------------------------------------------------------------------------------

Explanation
Use a stack to simulate inorder traversal (Left → Root → Right).
Keep track of the previous node’s value visited.
If the current node’s value is ≤ previous, the BST property is violated → return false.
If traversal finishes without violations, return true.

Complexity
Time: O(n) → each node is visited once.
Space: O(h) recursion stack, where h is tree height (O(log n) for balanced BST, O(n) for skewed).

Code
class Solution {
public:
    bool isValidBST(TreeNode* root) 
    {
        stack<TreeNode*> st;
        TreeNode* curr = root;
        long prev = LONG_MIN;

        while (curr || !st.empty())
        {
            while (curr) {
                st.push(curr);
                curr = curr->left;
            }
            curr = st.top();
            st.pop();

            if (curr->val <= prev) return false;
            prev = curr->val;

            curr = curr->right;
        }

        return true;
    }
};
ðŸŸ¢ Brute Force Approach
-------------------------------------------------------------------------------------------------------------------------------------

Explanation
Perform a DFS to record each nodeâ€™s depth and parent.
After traversal, compare the values for nodes x and y.
They are cousins if:
Depth of x == depth of y.
Parent of x != parent of y.

Time Complexity
O(n) â†’ Each node visited once.
Space Complexity
O(h) recursion stack (worst case O(n)).

Code
class Solution {
public:
    void dfs(TreeNode* root, int x, int y, int depth, 
             int parent, pair<int,int>& dx, pair<int,int>& dy) {
        if(!root) return;
        if(root->val == x) dx = {depth, parent};
        if(root->val == y) dy = {depth, parent};
        dfs(root->left, x, y, depth+1, root->val, dx, dy);
        dfs(root->right, x, y, depth+1, root->val, dx, dy);
    }

    bool isCousins(TreeNode* root, int x, int y) {
        pair<int,int> dx = {-1,-1}, dy = {-1,-1};
        dfs(root, x, y, 0, -1, dx, dy);
        return dx.first == dy.first && dx.second != dy.second;
    }
};


-------------------------------------------------------------------------------------------------------------------------------------
ðŸŸ  Optimized BFS Approach
-------------------------------------------------------------------------------------------------------------------------------------

Explanation
Use level-order traversal (queue).
For each level, check if both x and y are found.
If found under the same parent, return false (siblings).
If found on the same level but with different parents, return true.
If only one is found at a level, return false.

Time Complexity
O(n) â†’ Each node visited once.
Space Complexity
O(w) â†’ queue can hold up to the max width w (worst O(n)).

Code
class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        if(!root) return false;
        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()) {
            int n = q.size();
            bool fx = false, fy = false;

            for(int i = 0; i < n; i++) {
                TreeNode* curr = q.front(); q.pop();

                if(curr->left && curr->right) {
                    int l = curr->left->val, r = curr->right->val;
                    if((l == x && r == y) || (l == y && r == x))
                        return false;  
                }

                if(curr->left) {
                    q.push(curr->left);
                    if(curr->left->val == x) fx = true;
                    if(curr->left->val == y) fy = true;
                }

                if(curr->right) {
                    q.push(curr->right);
                    if(curr->right->val == x) fx = true;
                    if(curr->right->val == y) fy = true;
                }
            }
            if(fx && fy) return true;
            if(fx || fy) return false;
        }
        return false;
    }
};
Approach 1: Pure Recursion (No Memoization)
-------------------------------------------------------------------------------------------------

Explanation
Start from (0, 0) and recursively explore two choices:
Move Right → (i, j + 1)
Move Down → (i + 1, j)
Track:
c → current cost used.
k → maximum allowed cost.
At each cell:
Add score and cost based on the cell’s value (1 or 2).
Stop when cost exceeds k or reach bottom-right cell.
Return the maximum path score.

Complexity
Time: O(2^(m+n)) (each cell can branch twice).
Space: O(m + n) recursion depth.


class Solution {
public:
    int recur(int i, int j, vector<vector<int>>& grid, int k, int c)
    {
        int m = grid.size(), n = grid[0].size();

        if(i == m || j == n) 
            return INT_MIN;

        int addScore = 0, addCost = 0;
        if(grid[i][j] == 1) addScore = 1, addCost = 1;
        else if(grid[i][j] == 2) addScore = 2, addCost = 1;

        if(c + addCost > k)
            return INT_MIN;

        if(i == m - 1 && j == n - 1)
            return addScore;

        int right = recur(i, j + 1, grid, k, c + addCost);
        int down = recur(i + 1, j, grid, k, c + addCost);

        int best = max(right, down);
        return best == INT_MIN ? INT_MIN : addScore + best;
    }

    int maxPathScore(vector<vector<int>>& grid, int k)
    {
        int ans = recur(0, 0, grid, k, 0);
        return ans == INT_MIN ? -1 : ans;
    }
};

-------------------------------------------------------------------------------------------------
Approach 2: Top-Down DP (Memoization) ✅ (Your Code)
-------------------------------------------------------------------------------------------------

Explanation
Same recursive structure as above, but store results in dp[i][j][c].
Before computing a subproblem, check if it’s already solved.
Avoid recomputing overlapping subproblems.
Works efficiently for small to moderate k.

Complexity
Time: O(m × n × k)
Space: O(m × n × k) for DP + recursion stack.

class Solution {
public:
    int solve(int i, int j, vector<vector<int>>& grid, int k, int c, vector<vector<vector<int>>>& dp)
    {
        int m = grid.size(), n = grid[0].size();

        if(i == m || j == n) 
            return INT_MIN;

        if(dp[i][j][c] != -1) 
            return dp[i][j][c];

        int addScore = 0, addCost = 0;
        if(grid[i][j] == 1) addScore = 1, addCost = 1;
        else if(grid[i][j] == 2) addScore = 2, addCost = 1;

        if(c + addCost > k)
            return dp[i][j][c] = INT_MIN;

        if(i == m - 1 && j == n - 1)
            return dp[i][j][c] = addScore;

        int right = solve(i, j + 1, grid, k, c + addCost, dp);
        int down = solve(i + 1, j, grid, k, c + addCost, dp);
        int best = max(right, down);

        if(best == INT_MIN)
            return dp[i][j][c] = INT_MIN;

        return dp[i][j][c] = addScore + best;
    }

    int maxPathScore(vector<vector<int>>& grid, int k)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k + 1, -1)));

        int ans = solve(0, 0, grid, k, 0, dp);
        return ans == INT_MIN ? -1 : ans;
    }
};

-------------------------------------------------------------------------------------------------
Approach 3: Bottom-Up DP (Tabulation)
-------------------------------------------------------------------------------------------------

Explanation
Create a 3D DP table dp[i][j][c] representing max score to reach (i, j) using cost c.
Transition:
From top: dp[i-1][j][c-cost]
From left: dp[i][j-1][c-cost]
Take the maximum of both directions.
The answer is the max score at (m-1, n-1) for any cost ≤ k.

Complexity
Time: O(m × n × k)
Space: O(m × n × k)

class Solution {
public:
    int maxPathScore(vector<vector<int>>& grid, int k)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k + 1, INT_MIN)));

        int cost = (grid[0][0] > 0 ? 1 : 0);
        int score = (grid[0][0] == 1 ? 1 : (grid[0][0] == 2 ? 2 : 0));
        if(cost <= k) dp[0][0][cost] = score;

        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int addCost = (grid[i][j] > 0 ? 1 : 0);
                int addScore = (grid[i][j] == 1 ? 1 : (grid[i][j] == 2 ? 2 : 0));

                for(int c = addCost; c <= k; c++)
                {
                    if(i > 0 && dp[i-1][j][c-addCost] != INT_MIN)
                        dp[i][j][c] = max(dp[i][j][c], dp[i-1][j][c-addCost] + addScore);

                    if(j > 0 && dp[i][j-1][c-addCost] != INT_MIN)
                        dp[i][j][c] = max(dp[i][j][c], dp[i][j-1][c-addCost] + addScore);
                }
            }
        }

        int ans = INT_MIN;
        for(int c = 0; c <= k; c++)
            ans = max(ans, dp[m-1][n-1][c]);

        return ans == INT_MIN ? -1 : ans;
    }
};
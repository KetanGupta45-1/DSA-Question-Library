a) Brute Force Approach
-------------------------------------------------------------------------------------------------

Step 1: Rotate 90° clockwise
Create a new matrix ans of size n × m.
Copy each cell from grid[i][j] to ans[j][i], then reverse every row in ans.

Step 2: Gravity simulation
For each column in ans, move stones (#) downward until they either:
reach bottom,
hit an obstacle (*),
or sit on top of another stone.
Logic used for gravity
Use two pointers (x for the lowest available cell, y for current scanning).
Swap stones with empty cells . when found, and reset x when hitting *.
Return the rotated grid
After gravity adjustment, return ans.

Time Complexity
O(m × n) for rotation
O(m × n) for gravity simulation
Total = O(m × n)

Space Complexity
O(m × n) extra for rotated matrix

Code (Brute Force)
class Solution {
public:
    vector<vector<char>> rotateTheBox(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<char>> ans(n, vector<char>(m));

        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++)
                ans[j][i] = grid[i][j];
        }

        for(int i=0; i<ans.size(); i++) {
            int si=0, se=ans[0].size()-1;
            while(si<se) {
                swap(ans[i][si], ans[i][se]);
                si++; se--;
            }
        }

        m = ans.size(), n = ans[0].size();
        for(int col=0; col<n; col++) {
            int x=0, y=0;
            while(y<m) {
                if(ans[y][col]=='.') {
                    swap(ans[y][col], ans[x][col]);
                    x++;
                } else if(ans[y][col]=='*') {
                    x = y+1;
                }
                y++;
            }
        }

        return ans;
    }
};


-------------------------------------------------------------------------------------------------
b) Optimized Approach
-------------------------------------------------------------------------------------------------

Observation
Instead of creating a new rotated matrix and then simulating gravity, we can apply gravity first (in the original orientation), then directly rotate the box once.

Step 1: Apply gravity row-wise
For each row in grid, slide stones (#) to the rightmost available positions until blocked by *.
This simulates gravity correctly before rotation.

Step 2: Rotate once
After stones have already fallen inside each row, directly rotate the box 90° clockwise into ans.
No need for second gravity pass
Because we already did gravity in the original orientation, rotation alone gives the final state.
Return result
Final rotated matrix is already in the required form.

Time Complexity
O(m × n) single pass for gravity row-wise
O(m × n) for rotation
Total = O(m × n) (same as brute, but fewer operations inside rotation phase)

Space Complexity
O(m × n) for rotated matrix

Code (Optimized)
class Solution {
public:
    vector<vector<char>> rotateTheBox(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        for(int i=0; i<m; i++) {
            int empty = n-1;
            for(int j=n-1; j>=0; j--) {
                if(grid[i][j]=='*')
                    empty = j-1;
                else if(grid[i][j]=='#') {
                    swap(grid[i][j], grid[i][empty]);
                    empty--;
                }
            }
        }

        vector<vector<char>> ans(n, vector<char>(m));
        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++)
                ans[j][m-1-i] = grid[i][j];
        }

        return ans;
    }
};
Explanation
Traverse the grid, and whenever an unvisited land cell ('1') is found, start a DFS from it.
DFS marks all connected land cells as visited (exploring in 4 directions).
Each DFS call corresponds to discovering one new island.
Count the number of DFS calls triggered to get the total number of islands.

Time Complexity
O(n × m) → Each cell is visited at most once.

Space Complexity
O(n × m) → For the visited matrix and recursion stack in the worst case.

Code
class Solution {
public:
    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>&visited, int n, int m)
    {
        if(i<0 || j<0 || i == n || j == m || visited[i][j] || grid[i][j] == '0')
            return;
        
        visited[i][j] = true;
        dfs(i+1, j, grid, visited, n, m);
        dfs(i-1, j, grid, visited, n, m);
        dfs(i, j+1, grid, visited, n, m);
        dfs(i, j-1, grid, visited, n, m);

    }
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<bool>>visited(n, vector<bool>(m));
        int count = 0;

        for(int i = 0; i<n; i++)
        {
            for(int j =0; j<m; j++)
            {
                if(grid[i][j] == '1' && !visited[i][j])
                {
                    dfs(i, j, grid, visited, n, m);
                    count++;
                }
            }
        }
        return count;
    }
};
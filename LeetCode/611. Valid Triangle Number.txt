ðŸŸ¢ Brute Force
-------------------------------------------------------------------------------------------------------------------------------------

Explanation (4 Points)
A triangle is valid if the sum of any two sides is greater than the third side.
Sort the array so checking becomes easier.
Iterate over all possible triplets (i, j, k) with i < j < k.
Check if nums[i] + nums[j] > nums[k]. If true, count it as a valid triangle.

Complexity
Time: O(nÂ³).
Space: O(1).

Code
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        sort(nums.begin(), nums.end());

        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                for(int k=j+1; k<n; k++) {
                    if(nums[i] + nums[j] > nums[k])
                        ans++;
                }
            }
        }
        return ans;
    }
};


-------------------------------------------------------------------------------------------------------------------------------------
ðŸŸ  Binary Search
-------------------------------------------------------------------------------------------------------------------------------------

Explanation (4 Points)
Sort the array.
Fix two sides i and j.
Use binary search to find the largest index k such that nums[i] + nums[j] > nums[k].
All indices in range (j, k] form valid triangles â†’ add to answer.

Complexity
Time: O(nÂ² log n).
Space: O(1).

Code
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        sort(nums.begin(), nums.end());

        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                int sum = nums[i] + nums[j];
                int l = j+1, r = n-1, k = j;
                while(l <= r) {
                    int mid = (l+r)/2;
                    if(nums[mid] < sum) {
                        k = mid;
                        l = mid+1;
                    } else {
                        r = mid-1;
                    }
                }
                ans += (k - j);
            }
        }
        return ans;
    }
};


-------------------------------------------------------------------------------------------------------------------------------------
ðŸ”µ Two Pointers (Optimized)
-------------------------------------------------------------------------------------------------------------------------------------

Explanation (4 Points)
Sort the array.
Fix the largest side as nums[k].
Use two pointers i=0 and j=k-1.
If nums[i] + nums[j] > nums[k] â†’ all pairs from i to j-1 are valid (add j-i), then move j--. Else, move i++.

Complexity
Time: O(nÂ²).
Space: O(1).

Code (your version)
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        sort(nums.begin(), nums.end());

        for(int k=n-1; k>=2; k--) {
            int i=0, j=k-1;
            while(i<j) {
                if(nums[i] + nums[j] > nums[k]) {
                    ans += (j - i);
                    j--;
                } else {
                    i++;
                }
            }
        }
        return ans;
    }
};

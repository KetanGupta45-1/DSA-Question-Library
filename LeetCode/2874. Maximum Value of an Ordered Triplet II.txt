Brute Force Approach
---------------------------------------------------------------------------------------------------------------------------------------
Explanation

Iterate over all possible ordered triplets (i, j, k) where i < j < k.
For each triplet, calculate (nums[i] - nums[j]) * nums[k].
Keep track of the maximum value across all valid triplets.

Complexity
Time: O(n³) → three nested loops for all triplets.
Space: O(1) → only variables for tracking maximum.

Code
class Solution {
public:
    long long maximumTripletValue(vector<int>& nums) {
        int n = nums.size();
        long long ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                for(int k = j + 1; k < n; k++) {
                    long long val = (long long)(nums[i] - nums[j]) * nums[k];
                    ans = max(ans, val);
                }
            }
        }
        return ans;
    }
};


---------------------------------------------------------------------------------------------------------------------------------------
Optimized Approach
---------------------------------------------------------------------------------------------------------------------------------------
Explanation
Precompute the maximum element to the left of each index using leftmax.
Precompute the maximum element to the right of each index using rightmax.
For each index i, compute the triplet value (leftmax[i] - nums[i]) * rightmax[i].
Track the global maximum across all indices.
Return the maximum value found.

Complexity
Time: O(n) → three linear scans (left, right, final).
Space: O(n) → two auxiliary arrays leftmax and rightmax.

Code
class Solution {
public:
    long long maximumTripletValue(vector<int>& nums) {
        int n = nums.size();
        vector<int> leftmax(n, 0), rightmax(n, 0);
        long long ans = 0;

        for(int i = 1; i < n; i++)
            leftmax[i] = max(leftmax[i - 1], nums[i - 1]);

        for(int i = n - 2; i >= 0; i--)
            rightmax[i] = max(rightmax[i + 1], nums[i + 1]);

        for(int i = 0; i < n; i++) {
            long long val = (long long)(leftmax[i] - nums[i]) * rightmax[i];
            ans = max(ans, val);
        }
        return ans;
    }
};
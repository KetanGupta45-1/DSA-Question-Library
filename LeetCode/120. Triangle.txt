(a) Recursion (DFS) – Brute Force
-------------------------------------------------------------------------------------------------

Key points
At each level, we explore both possible moves: down or down-right.
Recursively compute the path sum and update minimum.
Exponential exploration without memoization → very slow.

Complexity
Time: O(2^n) (each row doubles choices).
Space: O(n) recursion stack.

Code (your version, simplified a bit):
class Solution {
public:
    int n, m;
    void dfs(vector<vector<int>>& triangle, int &mini_cost, int curr_cost, int cx, int cy)
    {
        if(cx == n)
        {
            mini_cost = min(mini_cost, curr_cost);
            return;
        }

        curr_cost += triangle[cx][cy];

        dfs(triangle, mini_cost, curr_cost, cx+1, cy);
        dfs(triangle, mini_cost, curr_cost, cx+1, cy+1);
    }

    int minimumTotal(vector<vector<int>>& triangle) {
        n = triangle.size();
        m = triangle[n-1].size();
        int mini_cost = INT_MAX;
        dfs(triangle, mini_cost, 0, 0, 0);
        return mini_cost;
    }
};


-------------------------------------------------------------------------------------------------
(b) Bottom-Up DP (Tabulation)
-------------------------------------------------------------------------------------------------

Key points
Start from the second-last row, add to each cell the min of its two children.
Reuse triangle array to store dp values in-place.
Final answer remains at triangle[0][0].

Complexity
Time: O(n^2).
Space: O(1) (in-place).

Code (your bottom-up version):
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        for(int i=n-2; i>=0; i--)
        {
            for(int j=0; j<triangle[i].size(); j++)
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);
        }
        return triangle[0][0];
    }
};


-------------------------------------------------------------------------------------------------
(c) Top-Down DP (Memoization)
-------------------------------------------------------------------------------------------------

Key points
Recursively compute minimum cost from top to bottom.
Cache results in dp array to avoid recomputation.
Much faster than plain recursion, since each subproblem is solved once.

Complexity
Time:  O(n^2) (all cells computed once).
Space: O(n^2) for dp + O(n) recursion stack.

Code:

class Solution {
public:
    int n;
    vector<vector<int>> dp;

    int solve(vector<vector<int>>& triangle, int i, int j)
    {
        if(i == n-1)
            return triangle[i][j];
        if(dp[i][j] != -1)
            return dp[i][j];

        int down = solve(triangle, i+1, j);
        int diag = solve(triangle, i+1, j+1);
        return dp[i][j] = triangle[i][j] + min(down, diag);
    }

    int minimumTotal(vector<vector<int>>& triangle) {
        n = triangle.size();
        dp.assign(n, vector<int>(n, -1));
        return solve(triangle, 0, 0);
    }
};
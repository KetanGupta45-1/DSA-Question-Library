Approach 1: Brute Force Backtracking
-------------------------------------------------------------------------------------------------

Explanation
Find an empty cell ('.').
Try placing digits '1' to '9' one by one.
For each placement, check if it’s valid:
Not repeated in the same row.
Not repeated in the same column.
Not repeated in the 3×3 subgrid.
If valid, recurse to the next cell.
If no valid number leads to a solution, backtrack (undo and try the next number).

Complexity
Time: O(9^(n²)) in the worst case (very large search space).
Space: O(n²) recursion depth.

class Solution {
public:
    bool isValid(vector<vector<char>>& board, int r, int c, char ch)
    {
        for(int i = 0; i < 9; i++)
        {
            if(board[r][i] == ch || board[i][c] == ch)
                return false;
            if(board[3*(r/3) + i/3][3*(c/3) + i%3] == ch)
                return false;
        }
        return true;
    }

    bool solve(vector<vector<char>>& board)
    {
        for(int r = 0; r < 9; r++)
        {
            for(int c = 0; c < 9; c++)
            {
                if(board[r][c] == '.')
                {
                    for(char ch = '1'; ch <= '9'; ch++)
                    {
                        if(isValid(board, r, c, ch))
                        {
                            board[r][c] = ch;
                            if(solve(board))
                                return true;
                            board[r][c] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    void solveSudoku(vector<vector<char>>& board)
    {
        solve(board);
    }
};

-------------------------------------------------------------------------------------------------
Approach 2: Optimized Backtracking with Hash Sets / Arrays
-------------------------------------------------------------------------------------------------

Explanation
Use 3 boolean arrays to track usage of digits:
row[i][d] — digit d used in row i
col[j][d] — digit d used in column j
box[b][d] — digit d used in 3×3 box b
(where b = (i/3)*3 + (j/3))
This allows O(1) validity checks instead of scanning the entire board every time.
Recursively fill empty cells as before, but update and backtrack usage flags.

Complexity
Time: Much faster than brute-force due to O(1) checks.
Space: O(9×9) for 3 boolean grids + recursion.

class Solution {
public:
    bool row[9][10] = {}, col[9][10] = {}, box[9][10] = {};

    bool solve(vector<vector<char>>& board, int r = 0, int c = 0)
    {
        if(r == 9) return true;
        if(c == 9) return solve(board, r + 1, 0);
        if(board[r][c] != '.') return solve(board, r, c + 1);

        int b = (r/3)*3 + (c/3);
        for(int num = 1; num <= 9; num++)
        {
            if(!row[r][num] && !col[c][num] && !box[b][num])
            {
                board[r][c] = num + '0';
                row[r][num] = col[c][num] = box[b][num] = true;

                if(solve(board, r, c + 1)) return true;

                board[r][c] = '.';
                row[r][num] = col[c][num] = box[b][num] = false;
            }
        }
        return false;
    }

    void solveSudoku(vector<vector<char>>& board)
    {
        for(int r = 0; r < 9; r++)
        {
            for(int c = 0; c < 9; c++)
            {
                if(board[r][c] != '.')
                {
                    int num = board[r][c] - '0';
                    int b = (r/3)*3 + (c/3);
                    row[r][num] = col[c][num] = box[b][num] = true;
                }
            }
        }
        solve(board);
    }
};

-------------------------------------------------------------------------------------------------
Approach 3: Bitmask Optimization (Most Efficient ⚡)
-------------------------------------------------------------------------------------------------

Explanation
Replace boolean grids with bitmasks to track used digits:
rows[i], cols[j], boxes[b] are integers (9 bits each).
Bit d in each mask represents if digit d is used.
Check validity in O(1) using bitwise operations.
Set and clear bits efficiently when placing or removing digits.
This version is the fastest and most memory efficient, ideal for large Sudoku solvers.

Complexity
Time: Practically near O(1) per placement (still exponential in worst-case, but extremely optimized).
Space: O(1) beyond board (only 27 integers for masks).

class Solution {
public:
    int rows[9] = {}, cols[9] = {}, boxes[9] = {};

    bool solve(vector<vector<char>>& board, int r = 0, int c = 0)
    {
        if(r == 9) return true;
        if(c == 9) return solve(board, r + 1, 0);
        if(board[r][c] != '.') return solve(board, r, c + 1);

        int b = (r/3)*3 + (c/3);
        for(int num = 1; num <= 9; num++)
        {
            int mask = 1 << num;
            if(!(rows[r] & mask) && !(cols[c] & mask) && !(boxes[b] & mask))
            {
                board[r][c] = num + '0';
                rows[r] |= mask;
                cols[c] |= mask;
                boxes[b] |= mask;

                if(solve(board, r, c + 1)) return true;

                board[r][c] = '.';
                rows[r] &= ~mask;
                cols[c] &= ~mask;
                boxes[b] &= ~mask;
            }
        }
        return false;
    }

    void solveSudoku(vector<vector<char>>& board)
    {
        for(int r = 0; r < 9; r++)
        {
            for(int c = 0; c < 9; c++)
            {
                if(board[r][c] != '.')
                {
                    int num = board[r][c] - '0';
                    int mask = 1 << num;
                    int b = (r/3)*3 + (c/3);
                    rows[r] |= mask;
                    cols[c] |= mask;
                    boxes[b] |= mask;
                }
            }
        }
        solve(board);
    }
};